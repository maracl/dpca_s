#include "video_info_dict.h"
#include <map>
#include <vector>
#include <time.h>
#include <string.h>
#include <stdlib.h> 
#include "byte_buffer.h"

typedef struct video_info {
	video_info(const string& p, long s, long e) : path(p), start(s), end(e) {}
	string path;
	long start;
	long end;
} video_info;
map<string, vector<video_info> > s_video_dict;

long time_ts(const char* time)
{
	/*(¸ñÊ½:YYYYMMDDHHMMSS)*/

	struct tm stm;
	int iY, iM, iD, iH, iMin, iS;

	memset(&stm, 0, sizeof(stm));

	char year[5] = { '\0' };
	memcpy(year, time, 4);
	iY = atoi(year);

	char month[3] = { '\0' };
	memcpy(month, time + 4, 2);
	iM = atoi(month);

	char day[3] = { '\0' };
	memcpy(day, time + 6, 2);
	iD = atoi(day);

	char hour[3] = { '\0' };
	memcpy(hour, time + 8, 2);
	iH = atoi(hour);

	char minute[3] = { '\0' };
	memcpy(minute, time + 10, 2);
	iMin = atoi(minute);

	char second[3] = { '\0' };
	memcpy(second, time + 12, 2);
	iS = atoi(second);

	stm.tm_year = iY - 1900;
	stm.tm_mon = iM - 1;
	stm.tm_mday = iD;
	stm.tm_hour = iH;
	stm.tm_min = iMin;
	stm.tm_sec = iS;
	return mktime(&stm);
}

string ts_time(long ts)
{
	char time[64];
	time_t tt = ts;
	struct tm tm;
	tm = *localtime(&tt);
	strftime(time, 64, "%Y-%m-%d %H:%M:%S", &tm);
	return time;
}

long long ts_time2(long ts)
{
	//char time[64];
	time_t tt = ts;
	struct tm tm;
	tm = *localtime(&tt);//
	//strftime(time, 64, "%Y%m%d%H%M%S", &tm);
	string time;
	format_string(time, "%d%02d%02d%02d%02d%02d", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
	long long ttl = (long long)atol(time.data());
	return ttl > 0 ? ttl : 19700101000000;
}

string video_info_find(const string& device, const string& start, const string& end)
{
	auto iter = s_video_dict.find(device);
	if (iter == s_video_dict.end())
		return "";

	long s = time_ts(start.data());
	long e = time_ts(end.data());
	for (auto info = iter->second.begin(); info != iter->second.end(); ++info) {
		if (info->start <= s && info->end >= e)
			return info->path;
	}

	return "";
}

static bool video_dict_init()
{
	auto split = [](std::string str, std::string pattern)-> std::vector<std::string>
	{
		std::string::size_type pos;
		std::vector<std::string> result;
		str += pattern;
		int size = str.size();

		for (int i = 0; i < size; i++)
		{
			pos = str.find(pattern, i);
			if (pos < size)
			{
				std::string s = str.substr(i, pos - i);
				result.push_back(s);
				i = pos + pattern.size() - 1;
			}
		}
		return result;
	};

	auto fill_dict = [&](const char* id)
	{
		vector<string> infos = split(id, "_");
		if (infos.size() != 3)
			return;

		string file_path;
		format_string(file_path, "/root/video/%s.mp4", id);
		s_video_dict[infos[0]].push_back(video_info(file_path, time_ts(infos[1].data()), time_ts(infos[2].data())));
	};

	//Â³B1Y91K
	fill_dict("37020001001311411513_20180107135507_20180107140130");
	fill_dict("37020001001311733028_20180107150451_20180107150846");
	fill_dict("37020001001311733451_20180107135958_20180107143520");
	fill_dict("37020001001311733451_20180107143452_20180107143750");
	fill_dict("37020001001311733694_20180107142950_20180107143519");
	fill_dict("37020001001311733725_20180107135948_20180107142215");
	fill_dict("37021104001310024702_20180107140303_20180107140734");
	fill_dict("37021104001310026677_20180107140249_20180107140604");
	fill_dict("37021104001310159324_20180107150532_20180107150829");
	fill_dict("37021108041310014746_20180107150501_20180107150859");
	fill_dict("37021108041310019909_20180107140002_20180107140514");

	//Â³B7D7B8
	fill_dict("37020001001311732678_20180111212511_20180111214008");
	fill_dict("37021101001310024131_20180111170726_20180111171106");
	fill_dict("37021101001310045523_20180111200411_20180111201006");
	fill_dict("37021101001310147803_20180111195915_20180111201719");
	fill_dict("37021101001310148220_20180111170717_20180111171109");
	fill_dict("37021101001310150783_20180111200813_20180111201507");
	fill_dict("37021101001310157859_20180111212947_20180111214146");
	fill_dict("37021101001310179951_20180111200422_20180111200916");
	fill_dict("37021108041310017256_20180111195931_20180111200739");

	//Â³B18NW1
	fill_dict("37021101001310020097_20180116090942_20180116092938");
	fill_dict("37021101001310025547_20180116090847_20180116091752");
	fill_dict("37021102001310021786_20180116095010_20180116095540");
	fill_dict("37021102001310022280_20180116095111_20180116095947");
	fill_dict("37021102001310022322_20180116094843_20180116095553");
	fill_dict("37021102001310027977_20180116094859_20180116100300");
	fill_dict("37021104001310021351_20180116093426_20180116093740");
	fill_dict("37021104001310035357_20180116093345_20180116093720");
	fill_dict("37021104001310146697_20180116090922_20180116091148");
	fill_dict("37021104001310149320_20180116090852_20180116091430");
	fill_dict("37021108041310018457_20180116091005_20180116091432");
	fill_dict("37021108041310018457_20180116092954_20180116093728");

	//Â³BB1B75
	fill_dict("37020001001311731543_20180102084505_20180102085258");
	fill_dict("37021101001310021260_20180102084542_20180102085502");
	fill_dict("37021101001310022657_20180102084520_20180102085033");
	fill_dict("37021101001310023065_20180102084806_20180102085027");
	fill_dict("37021101001310027656_20180102084804_20180102085254");
	fill_dict("37021101001310027743_20180102084510_20180102085204");
	fill_dict("37021101001310027910_20180102084805_20180102085253");
	fill_dict("37021101001310028622_20180102084807_20180102085120");
	fill_dict("37021101001310028709_20180102084514_20180102085205");
	fill_dict("37021101001310051569_20180102084003_20180102084931");
	fill_dict("37021101001310053502_20180102084004_20180102084905");
	fill_dict("37021101001310056080_20180102084804_20180102085254");
	fill_dict("37021101001310051569_20180102084003_20180102084931");
	fill_dict("37021101001310056697_20180102084205_20180102084849");
	fill_dict("37021101001310064475_20180102084500_20180102085001");
	fill_dict("37021101001310067964_20180102084211_20180102085023");
	fill_dict("37021101001310070711_20180102084001_20180102094901");
	fill_dict("37021101001310160086_20180102084253_20180102084801");
	fill_dict("37021101001310170402_20180102084536_20180102085035");

	//Â³BM7319
	fill_dict("37021101001310027812_20180115092205_20180115092859");
	fill_dict("37021101001310045523_20180115092431_20180115093551");
	fill_dict("37021101001310176952_20180115092245_20180115092851");
	fill_dict("37021103001310022549_20180115091854_20180115092433");
	fill_dict("37021103001310024398_20180115091604_20180115092009");
	fill_dict("37021103001310025762_20180115091855_20180115092434");
	fill_dict("37021103001310028783_20180115091854_20180115092445");
	fill_dict("37021103001310045858_20180115091853_20180115092448");
	fill_dict("37021105001310170075_20180115091851_20180115092005");
	fill_dict("37021108041310016375_20180115092639_20180115093350");
	fill_dict("37021108041310017703_20180115092001_20180115092510");

	//Â³BQ2U15
	fill_dict("37021101001310020051_20180108091951_20180108093245");
	fill_dict("37021101001310020566_20180108091351_20180108091855");
	fill_dict("37021101001310022654_20180108091549_20180108092029");
	fill_dict("37021101001310023065_20180108091153_20180108091718");
	fill_dict("37021101001310025209_20180108091548_20180108092122");
	fill_dict("37021101001310026684_20180108091549_20180108092019");
	fill_dict("37021101001310027743_20180108091149_20180108091635");
	fill_dict("37021101001310028709_20180108091151_20180108091603");
	fill_dict("37021101001310028877_20180108091448_20180108091952");
	fill_dict("37021101001310178375_20180108091747_20180108091936");
	fill_dict("37021108041310017663_20180108091102_20180108091606");

	//ÃöBQ9973
	fill_dict("37021101001310020727_20180114121854_20180114122421");
	fill_dict("37021101001310022656_20180114122059_20180114122455");
	fill_dict("37021101001310022705_20180114121857_20180114122233");
	fill_dict("37021101001310023015_20180114121856_20180114122405");
	fill_dict("37021101001310023015_20180114122057_20180114122418");
	fill_dict("37021101001310026737_20180114121910_20180114122221");
	fill_dict("37021101001310060590_20180114122053_20180114122908");
	fill_dict("37021101001310061857_20180114122447_20180114123535");
	fill_dict("37021101001310064860_20180114122352_20180114122900");
	fill_dict("37021101001310064860_20180114132852_20180114133424");
	fill_dict("37021101001310141102_20180114121658_20180114122213");
	fill_dict("37021101001310142253_20180114122035_20180114122820");
	fill_dict("37021101001310142253_20180114132833_20180114133430");
	fill_dict("37021101001310146606_20180114122151_20180114122343");
	fill_dict("37021101001310160086_20180114122435_20180114122712");
	fill_dict("37021101001310172540_20180114122355_20180114122625");
	fill_dict("37021108041310014024_20180114122216_20180114122435");
	fill_dict("37021108041310019053_20180114122154_20180114122742");

	//for (auto iter = s_video_dict.begin(); iter != s_video_dict.end(); ++iter) {
	//	for (auto info = iter->second.begin(); info != iter->second.end(); ++info) {
	//		printf("%s %ld %ld\n", iter->first.data(), info->start, info->end);
	//	}
	//}
	return true;
}

static bool s_dummy = video_dict_init();
